From f7a0f208dbda47badf35af220d4c21b35b0f2d27 Mon Sep 17 00:00:00 2001
From: Piotr Trojanek <piotr.trojanek@gmail.com>
Date: Fri, 1 Nov 2013 14:46:27 +0000
Subject: [PATCH 11/18] keep using old frontend's interface (see M820-007)

---
 gnat2why/spark/spark_definition.adb | 70 +++++++++++++++++++++++++++++++------
 1 file changed, 59 insertions(+), 11 deletions(-)

diff --git a/gnat2why/spark/spark_definition.adb b/gnat2why/spark/spark_definition.adb
index 71da7fd..554fa6c 100644
--- a/gnat2why/spark/spark_definition.adb
+++ b/gnat2why/spark/spark_definition.adb
@@ -33,6 +33,7 @@ with Ada.Containers.Hashed_Maps;
 with Atree;                              use Atree;
 with Einfo;                              use Einfo;
 with Errout;                             use Errout;
+with Lib;
 with Namet;                              use Namet;
 with Nlists;                             use Nlists;
 with Opt;
@@ -61,9 +62,9 @@ package body SPARK_Definition is
    --    types and deferred constants
 
    --  The SPARK_Mode pragma may be used as a configuration pragma or a local
-   --  pragma in the source. The frontend rejects all invalid placements
-   --  of this pragma, and stores them in the attributes "SPARK_Pragma"
-   --  and "SPARK_Aux_Pragma" of the relevant entities:
+   --  pragma in the source. The frontend rejects all invalid placements of
+   --  this pragma, and stores them in the attribute "SPARK_Mode_Pragmas" of
+   --  the relevant entities:
 
    --      E_Function
    --      E_Generic_Function
@@ -74,13 +75,31 @@ package body SPARK_Definition is
    --      E_Package
    --      E_Package_Body
 
-   --  There is a special type called SPARK_Mode_Type which defines the various
+   --  [Generic] package specs and bodies may have two pragmas. Those are
+   --  linked using the Next_Pragma field. To distinguish between pragmas that
+   --  apply to the visible or private part of a spec, one can use function
+   --
+   --      sem_prag.Is_Private_SPARK_Mode
+   --
+   --  To distinguish between pragmas that apply to the declarative and
+   --  statement part of a body, one can use function
+   --
+   --      sem_prag.Is_Elaboration_SPARK_Mode
+   --
+   --  The unit-wide configuration version of the pragma is associated
+   --  with the unit itself. See the facilities in lib.ads and function
+   --  SPARK_Mode_Pragma.
+   --
+   --  The compilation-wide configuration mode of the pragma is retained in
+   --  opt.ads. See opt.ads.
+   --
+   --  There is a special type called SPARK_Mode_Id which defines the various
    --  modes. There is a useful function in sem_prag to extract the Mode_Id
    --  from a pragma
    --
-   --      sem_prag.Get_SPARK_Mode_Type
+   --      sem_prag.Get_SPARK_Mode_Id
    --
-   --  The idea is that one should compare SPARK_Mode_Type values rather than
+   --  The idea is that one should compare SPARK_Mode_Id values rather than
    --  Name_Ids.
 
    package Applicable_SPARK_Mode is new
@@ -259,6 +278,17 @@ package body SPARK_Definition is
    --  Start of Get_Scope_Info
 
    begin
+      --  Get the applicable SPARK_Mode pragma for this unit, if any
+
+      if Nkind (Parent (N)) = N_Compilation_Unit then
+
+         --  ??? After Opt.Global_SPARK_Mode is changed to a Node_Id, this is
+         --  the place to push it on the stack.
+
+         Push_SPARK_Pragma
+           (Lib.SPARK_Mode_Pragma (Lib.Get_Cunit_Unit_Number (Parent (N))));
+      end if;
+
       --  Traversal currently stops at non-declarations (except
       --  N_Handled_Sequence_Of_Statements and N_Block_Statement which may
       --  contain declarations) which is sufficient to get the applicable
@@ -338,7 +368,7 @@ package body SPARK_Definition is
                       E_Package           |
                       E_Package_Body
       then
-         Prag := SPARK_Pragma (E);
+         Prag := SPARK_Mode_Pragmas (E);
       end if;
 
       case Nkind (N) is
@@ -355,8 +385,17 @@ package body SPARK_Definition is
             --  Retrieve the SPARK_Mode pragmas on the visible and private
             --  parts of the package, if any.
 
-            Vis_Prag := Prag;
-            Priv_Prag := SPARK_Aux_Pragma (E);
+            if Present (Prag)
+              and then not Sem_Prag.Is_Private_SPARK_Mode (Prag)
+            then
+               Vis_Prag := Prag;
+               Prag := Next_Pragma (Prag);
+            end if;
+
+            if Present (Prag) then
+               pragma Assert (Sem_Prag.Is_Private_SPARK_Mode (Prag));
+               Priv_Prag := Prag;
+            end if;
 
             --  Do the package entity itself and its visible part
 
@@ -392,8 +431,17 @@ package body SPARK_Definition is
             --  Retrieve the SPARK_Mode pragmas on the declarative and
             --  statement parts of the package body, if any.
 
-            Decl_Prag := Prag;
-            Stat_Prag := SPARK_Aux_Pragma (E);
+            if Present (Prag)
+              and then not Sem_Prag.Is_Elaboration_SPARK_Mode (Prag)
+            then
+               Decl_Prag := Prag;
+               Prag := Next_Pragma (Prag);
+            end if;
+
+            if Present (Prag) then
+               pragma Assert (Sem_Prag.Is_Elaboration_SPARK_Mode (Prag));
+               Stat_Prag := Prag;
+            end if;
 
             --  Do the package body entity itself and its declarative part
 
-- 
1.9.0

